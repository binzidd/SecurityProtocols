import os
from Crypto.Random import random
from Crypto.Hash import SHA256
from Crypto.Cipher import AES
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP
from Crypto.Signature import PKCS1_PSS

# Instead of storing files on disk,
# we'll save them in memory for simplicity
filestore = {}
# Valuable data to be sent to the botmaster
valuables = []

def save_valuable(data):
    valuables.append(data)


def encrypt_for_master(data):
    # Encrypt the file so it can only be read by the bot master
    # Data is encrypted using AES
    # AES Key and IV are encrypted and sent across using RSA

    # Generating AES IV
    random_iv = random.randint(2 ** 128, 2 ** 2048)
    hash_iv = SHA256.new(bytes(str(random_iv), "ascii")).digest()
    random_iv_short = (hash_iv)[:16]

    # Generating AES KEY
    aes_key = random.randint(2 ** 1048, 2 ** 4096)
    hash_key = SHA256.new(bytes(str(aes_key), "ascii")).digest()
    aes_key_short = hash_key[:16]

    # AES encryption of data
    cipher = AES.new(aes_key_short, AES.MODE_CFB, random_iv_short)
    encrypted_data_aes = cipher.encrypt(data)

    # RSA encryption of AES IV and Key
    # payload here is IV and Key
    payload_rsa = random_iv_short + aes_key_short

    # hashing Key and IV for verification at master bot
    payload_hash = SHA256.new(payload_rsa).digest()

    # importing the public key generated by OpenSSL 
    # Generated by OpenSSL & 4096 size for better security 
    # Not hardcoding it into the directory rather importing it. 
    public_key_master = RSA.importKey(open('public_key.pem').read())

    # Encrypting the payload using RSA
    cipher_rsa = PKCS1_OAEP.new(public_key_master)
    final_payload_rsa = bytes(payload_rsa) + payload_hash
    encrypted_data_rsa = cipher_rsa.encrypt(final_payload_rsa)

    # Final Payload  = RSA(IV+KEY+HASH) + AES(DATA)
    encrypted_data = encrypted_data_rsa + encrypted_data_aes

    return encrypted_data


def upload_valuables_to_pastebot(fn):
    # Encrypt the valuables so only the bot master can read them
    valuable_data = "\n".join(valuables)
    valuable_data = bytes(valuable_data, "ascii")
    encrypted_master = encrypt_for_master(valuable_data)

    # "Upload" it to pastebot (i.e. save in pastebot folder)
    f = open(os.path.join("pastebot.net", fn), "wb")
    f.write(encrypted_master)
    f.close()

    print("Saved valuables to pastebot.net/%s for the botnet master" % fn)


def verify_file(f):
    # Verify the file was sent by the bot master

    # Split the data and signature
    received_data = f[512:]
    received_signature = f[:512]

    # Obtain the public key for master
    public_key_master = open("public_key.pem").read()

    # Import the Public Key
    rsa_key = RSA.importKey(public_key_master)

    # creating signer with PKCS1_PSS and digest
    signer = PKCS1_PSS.new(rsa_key)
    digest = SHA256.new(received_data)

    if signer.verify(digest, received_signature):
        print('Signature is authentic')
        return True
    else:
        print('Signature is not authentic. This is not Master')
        return False


def process_file(fn, f):
    if verify_file(f):
        # If it was, store it unmodified
        # (so it can be sent to other bots)
        # Decrypt and run the file
        filestore[fn] = f
        print("Stored the received file as %s" % fn)
    else:
        print("The file has not been signed by the botnet master")


def download_from_pastebot(fn):
    # "Download" the file from pastebot.net
    # (i.e. pretend we are and grab it from disk)
    # Open the file as bytes and load into memory
    if not os.path.exists(os.path.join("pastebot.net", fn)):
        print("The given file doesn't exist on pastebot.net")
        return
    f = open(os.path.join("pastebot.net", fn), "rb").read()
    process_file(fn, f)


def p2p_download_file(sconn):
    # Download the file from the other bot
    fn = str(sconn.recv(), "ascii")
    f = sconn.recv()
    print("Receiving %s via P2P" % fn)
    process_file(fn, f)


def p2p_upload_file(sconn, fn):
    # Grab the file and upload it to the other bot
    # You don't need to encrypt it only files signed
    # by the botnet master should be accepted
    # (and your bot shouldn't be able to sign like that!)
    if fn not in filestore:
        print("That file doesn't exist in the botnet's filestore")
        return
    print("Sending %s via P2P" % fn)
    sconn.send(fn)
    sconn.send(filestore[fn])


def run_file(f):
    # If the file can be run,
    # run the commands
    pass
